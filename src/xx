2,5c2
< * Calls photosynthesis model, water balance and evolves aboveground plant
< * C & Nstate. Pools recieve C through allocation of accumulated photosynthate
< * and N from both soil uptake and retranslocation within the plant. Key feedback
< * through soil N mineralisation and plant N uptake
---
> * Generic Decomposition And Yield (GDAY) model.
6a4,6
> * G'DAY is a process based model, which runs on a daily timestep and
> * simulates carbon, nutrient and water state and fluxes. See below for model
> * description.
8c8
< * NOTES:
---
> * Paramaeter descriptions are in gday.h
9a10,11
> * NOTES:
> *   I'm essentially transfering the python to C here...
15c17
< *   17.02.2015
---
> *   27.02.2015
17a20,24
> 
> #include "gday.h"
> #include "constants.h"
> #include "utilities.h"
> #include "litter_production.h"
18a26
> #include "mate.h"
19a28,36
> #include "simple_moving_average.h"
> #include "soils.h"
> #include "optimal_root_model.h"
> #include "initialise_model.h"
> #include "write_output_file.h"
> #include "version.h"
> #include "phenology.h"
> #include "read_param_file.h"
> #include "read_met_file.h"
21,26c38
< 
< 
< 
< void calc_day_growth(control *c, fluxes *f, met *m, params *p, state *s,
<                      int project_day, double day_length, int doy, double fdecay,
<                      double rdecay)
---
> int main(int argc, char **argv)
28,34c40
<     double previous_topsoil_store,
<            previous_rootzone_store, nitfac, ncbnew, nccnew, ncwimm, ncwnew;
<     int    recalc_wb;
< 
<     /* Store the previous days soil water store */
<     previous_topsoil_store = s->pawater_topsoil;
<     previous_rootzone_store = s->pawater_root;
---
>     int error = 0;
35a42,49
>     /*
>     ** Setup structures, initialise stuff, e.g. zero fluxes.
>     */
>     control *c;
>     fluxes *f;
>     met *m;
>     params *p;
>     state *s;
37,43c51,54
<     if (c->sub_daily) {
<         /* calculate 30-min GPP/NPP, respiration and water fluxes */
<         canopy(c, f, m, p, s);
<     } else {
<         /* calculate daily GPP/NPP, respiration and update water balance */
<         carbon_daily_production(c, f, m, p, s, project_day, day_length);
<         calculate_daily_water_balance(c, f, m, p, s, project_day, day_length);
---
>     c = (control *)malloc(sizeof (control));
>     if (c == NULL) {
>         fprintf(stderr, "control structure: Not allocated enough memory!\n");
>     	exit(1);
46,75c57,60
<     /*printf("* %lf\n", f->gpp);*/
< 
< 
<     /* leaf N:C as a fraction of Ncmaxyoung, i.e. the max N:C ratio of
<        foliage in young stand */
<     nitfac = MIN(1.0, s->shootnc / p->ncmaxfyoung);
< 
<     /* figure out the C allocation fractions */
<     if (c->deciduous_model){
<         /* Allocation is annually for deciduous "tree" model, but we need to
<            keep a check on stresses during the growing season and the LAI
<            figure out limitations during leaf growth period. This also
<            applies for deciduous grasses, need to do the growth stress
<            calc for grasses here too. */
<         if (s->leaf_out_days[doy] > 0.0) {
< 
<             calc_carbon_allocation_fracs(c, f, p, s, nitfac);
< 
<             /* store the days allocation fraction, we average these at the
<                end of the year (for the growing season) */
<             s->avg_alleaf += f->alleaf;
<             s->avg_albranch += f->albranch;
<             s->avg_alstem += f->alstem;
<             s->avg_alroot += f->alroot;
<             s->avg_alcroot += f->alcroot;
< 
<         }
<     } else {
<         /* daily allocation...*/
<         calc_carbon_allocation_fracs(c, f, p, s, nitfac);
---
>     f = (fluxes *)malloc(sizeof (fluxes));
>     if (f == NULL) {
>     	fprintf(stderr, "fluxes structure: Not allocated enough memory!\n");
>     	exit(1);
78,88c63,66
<     /* Distribute new C and N through the system */
<     carbon_allocation(c, f, p, s, nitfac, doy);
< 
<     calculate_ncwood_ratios(c, p, s, nitfac, &ncbnew, &nccnew, &ncwimm,
<                             &ncwnew);
< 
<     recalc_wb = nitrogen_allocation(c, f, p, s, ncbnew, nccnew, ncwimm, ncwnew,
<                                     fdecay, rdecay, doy);
< 
<     if (c->exudation) {
<         calc_root_exudation_release(f, s);
---
>     m = (met *)malloc(sizeof (met));
>     if (m == NULL) {
>     	fprintf(stderr, "met structure: Not allocated enough memory!\n");
>     	exit(1);
91,110c69,72
<     /* If we didn't have enough N available to satisfy wood demand, NPP
<        is down-regulated and thus so is GPP. We also need to recalculate the
<        water balance given the lower GPP. */
<     if (recalc_wb) {
<         s->pawater_topsoil = previous_topsoil_store;
<         s->pawater_root = previous_rootzone_store;
< 
<         if (c->sub_daily) {
<             /* calculate 30-min GPP/NPP, respiration and water fluxes */
<             /* DONT WANT TO DO THIScanopy(c, f, m, p, s);*/
< 
<             /* need to fix */
<             double blah = 0.0;
< 
< 
<         } else {
<             calculate_daily_water_balance(c, f, m, p, s, project_day,
<                                           day_length);
<         }
< 
---
>     p = (params *)malloc(sizeof (params));
>     if (p == NULL) {
>     	fprintf(stderr, "params structure: Not allocated enough memory!\n");
>     	exit(1);
112,116d73
<     update_plant_state(c, f, p, s, fdecay, rdecay, doy);
<     precision_control(f, s);
< 
<     return;
< }
118,141c75,78
< void calc_root_exudation_release(fluxes *f, state *s) {
<     /* Root exudation modelled to occur: with (1) fine root growth or (2)
<        as a result of excess C. A fraction of fine root growth is allocated
<        to stimulate exudation. This fraction increases with N stress. */
<     double leaf_CN, frac_to_rexc, presc_leaf_CN, fine_root_NC;
< 
<     if (float_eq(s->shoot, 0.0) || float_eq(s->shootn, 0.0)) {
<         /* nothing happens during leaf off period */
<         leaf_CN = 0.0;
<         frac_to_rexc = 0.0;
<     } else {
<         leaf_CN = 1.0 / s->shootnc;
<         presc_leaf_CN = 30.0; /* make a parameter */
< 
<         /* fraction varies between 0 and 50 % as a function of leaf CN */
<         frac_to_rexc = MAX(0.0, MIN(0.5, (leaf_CN / presc_leaf_CN) - 1.0));
<     }
<     /*printf("%f %f\n", s->shootnc, 1./30.);*/
<     f->root_exc = frac_to_rexc * f->cproot;
<     if (float_eq(f->cproot, 0.0)) {
<         f->root_exn = 0.0;
<     } else {
<         fine_root_NC = f->nproot / f->cproot;
<         f->root_exn = f->root_exc * fine_root_NC;
---
>     s = (state *)malloc(sizeof (state));
>     if (s == NULL) {
>     	fprintf(stderr, "state structure: Not allocated enough memory!\n");
>     	exit(1);
144,147c81,84
<     /* Need to exudation C & N fluxes from fine root growth fluxes so that
<        things balance. */
<     f->cproot -= f->root_exc;
<     f->nproot -= f->root_exn;
---
>     initialise_control(c);
>     initialise_params(p);
>     initialise_fluxes(f);
>     initialise_state(s);
149,164c86,88
<     return;
< }
< void carbon_daily_production(control *c, fluxes *f, met *m, params *p, state *s,
<                              int project_day, double daylen) {
<     /* Calculate GPP, NPP and plant respiration at the daily timestep
< 
<     Parameters:
<     -----------
<     project_day : integer
<         simulation day
<     daylen : float
<         daytime length (hrs)
< 
<     References:
<     -----------
<     * Jackson, J. E. and Palmer, J. W. (1981) Annals of Botany, 47, 561-565.
---
>     clparser(argc, argv, c);
>     /*
>     ** Read .ini parameter file and meterological data
166,230c90,96
<     double leafn, fc, ncontent;
< 
<     if (s->lai > 0.0) {
<         /* average leaf nitrogen content (g N m-2 leaf) */
<         leafn = (s->shootnc * p->cfracts / p->sla * KG_AS_G);
< 
<         /* total nitrogen content of the canopy */
<         ncontent = leafn * s->lai;
< 
<     } else {
<         ncontent = 0.0;
<     }
< 
<     /* When canopy is not closed, canopy light interception is reduced
<         - calculate the fractional ground cover */
<     if (s->lai < p->lai_closed) {
<         /* discontinuous canopies */
<         fc = s->lai / p->lai_closed;
<     } else {
<         fc = 1.0;
<     }
< 
<     /* fIPAR - the fraction of intercepted PAR = IPAR/PAR incident at the
<        top of the canopy, accounting for partial closure based on Jackson
<        and Palmer (1979). */
<     if (s->lai > 0.0)
<         s->fipar = ((1.0 - exp(-p->kext * s->lai / fc)) * fc);
<     else
<         s->fipar = 0.0;
< 
<     if (c->water_stress) {
<         /* Calculate the soil moisture availability factors [0,1] in the
<            topsoil and the entire root zone */
<         calculate_soil_water_fac(c, p, s);
<     } else {
<         /* really this should only be a debugging option! */
<         s->wtfac_topsoil = 1.0;
<         s->wtfac_root = 1.0;
<     }
<     /* Estimate photosynthesis */
<     if (c->assim_model == BEWDY){
<         exit(EXIT_FAILURE);
<     } else if (c->assim_model == MATE) {
<         if (c->ps_pathway == C3) {
<             mate_C3_photosynthesis(c, f, m, p, s, project_day, daylen,
<                                    ncontent);
<         } else {
<             mate_C4_photosynthesis(c, f, m, p, s, project_day, daylen,
<                                    ncontent);
<         }
<     } else {
<         fprintf(stderr,"Unknown photosynthesis model'");
<         exit(EXIT_FAILURE);
<     }
< 
< 
<     /* Calculate plant respiration */
<     if (c->respiration_model == FIXED) {
<         /* Plant respiration assuming carbon-use efficiency. */
<         f->auto_resp = f->gpp * p->cue;
<     } else if(c->respiration_model == TEMPERATURE) {
<         fprintf(stderr, "Not implemented yet");
<         exit(EXIT_FAILURE);
<     } else if (c->respiration_model == BIOMASS) {
<         fprintf(stderr, "Not implemented yet");
---
>     error = parse_ini_file(c, p, s);
>     if (error != 0) {
>         prog_error("Error reading .INI file on line", __LINE__);
>     }
>     strcpy(c->git_code_ver, build_git_sha);
>     if (c->PRINT_GIT) {
>         fprintf(stderr, "\n%s\n", c->git_code_ver);
234,246c100
<     /* Calculate NPP */
<     f->npp_gCm2 = f->gpp_gCm2 * p->cue;
<     f->npp = f->npp_gCm2 * GRAM_C_2_TONNES_HA;
< 
<     return;
< }
< 
< void calculate_ncwood_ratios(control *c, params *p, state *s, double nitfac,
<                              double *ncbnew, double *nccnew, double *ncwimm,
<                              double *ncwnew) {
<     /* Estimate the N:C ratio in the branch and stem. Option to vary
<     the N:C ratio of the stem following Jeffreys (1999) or keep it a fixed
<     fraction
---
>     read_met_data(argv, c, m);
248,294c102,105
<     Parameters:
<     -----------
<     nitfac : float
<         leaf N:C as a fraction of the max N:C ratio of foliage in young
<         stand
< 
<     Returns:
<     --------
<     ncbnew : float
<         N:C ratio of branch
<     nccnew : double
<         N:C ratio of coarse root
<     ncwimm : float
<         N:C ratio of immobile stem
<     ncwnew : float
<         N:C ratio of mobile stem
< 
<     References:
<     ----------
<     * Jeffreys, M. P. (1999) Dynamics of stemwood nitrogen in Pinus radiata
<       with modelled implications for forest productivity under elevated
<       atmospheric carbon dioxide. PhD.
<     */
< 
<     /* n:c ratio of new branch wood*/
<     *ncbnew = p->ncbnew + nitfac * (p->ncbnew - p->ncbnewz);
< 
<     /* n:c ratio of coarse root */
<     *nccnew = p->nccnew + nitfac * (p->nccnew - p->nccnewz);
< 
<     /* fixed N:C in the stemwood */
<     if (c->fixed_stem_nc) {
<         /* n:c ratio of stemwood - immobile pool and new ring */
<         *ncwimm = p->ncwimm + nitfac * (p->ncwimm - p->ncwimmz);
< 
<         /* New stem ring N:C at critical leaf N:C (mobile) */
<         *ncwnew = p->ncwnew + nitfac * (p->ncwnew - p->ncwnewz);
< 
<    /* vary stem N:C based on reln with foliage, see Jeffreys. Jeffreys 1999
<       showed that N:C ratio of new wood increases with foliar N:C ratio,
<       modelled here based on evidence as a linear function. */
<    } else {
<         *ncwimm = MAX(0.0, (0.0282 * s->shootnc + 0.000234) * p->fhw);
< 
<         /* New stem ring N:C at critical leaf N:C (mobile) */
<         *ncwnew = MAX(0.0, 0.162 * s->shootnc - 0.00143);
<     }
---
>     if (c->spin_up)
>         spin_up_pools(c, f, m, p, s);
>     else
>         run_sim(c, f, m, p, s);
296c107,140
<     return;
---
>     /* clean up */
>     fclose(c->ofp);
>     fclose(c->ifp);
>     if (c->output_ascii == FALSE) {
>         fclose(c->ofp_hdr);
>     }
> 
>     free(c);
>     free(f);
>     free(m->year);
>     free(m->prjday);
>     free(m->sw_rad);
>     free(m->tair);
>     free(m->rain);
>     free(m->tsoil);
>     free(m->tam);
>     free(m->tpm);
>     free(m->vpd_am);
>     free(m->vpd_pm);
>     free(m->vpd_avg);
>     free(m->co2);
>     free(m->ndep);
>     free(m->wind);
>     free(m->press);
>     free(m->par);
>     free(m->wind_am);
>     free(m->wind_pm);
>     free(m->sw_rad_am);
>     free(m->sw_rad_pm);
>     free(m);
>     free(p);
>     free(s);
> 
>     exit(EXIT_SUCCESS);
301,363c145,157
< int nitrogen_allocation(control *c, fluxes *f, params *p, state *s,
<                         double ncbnew, double nccnew, double ncwimm,
<                         double ncwnew, double fdecay, double rdecay, int doy) {
<     /* Nitrogen distribution - allocate available N through system.
<     N is first allocated to the woody component, surplus N is then allocated
<     to the shoot and roots with flexible ratios.
< 
<     References:
<     -----------
<     McMurtrie, R. E. et al (2000) Plant and Soil, 224, 135-152.
< 
<     Parameters:
<     -----------
<     ncbnew : float
<         N:C ratio of branch
<     ncwimm : float
<         N:C ratio of immobile stem
<     ncwnew : float
<         N:C ratio of mobile stem
<     fdecay : float
<         foliage decay rate
<     rdecay : float
<         fine root decay rate
<     */
< 
<     int    recalc_wb;
<     double nsupply, rtot, ntot, arg, lai_inc = 0.0, conv;
<     double depth_guess = 1.0, total_req;
<     int    OLD = FALSE;
< 
<     /* default is we don't need to recalculate the water balance,
<        however if we cut back on NPP due to available N below then we do
<        need to do this */
<     recalc_wb = FALSE;
< 
<     /* N retranslocated proportion from dying plant tissue and stored within
<        the plant */
<     f->retrans = nitrogen_retrans(c, f, p, s, fdecay, rdecay, doy);
<     f->nuptake = calculate_nuptake(c, p, s);
< 
<     /*  Ross's Root Model. */
<     if (c->model_optroot) {
< 
<         /* convert t ha-1 day-1 to gN m-2 year-1 */
<         nsupply = (calculate_nuptake(c, p, s) *
<                    TONNES_HA_2_G_M2 * DAYS_IN_YRS);
< 
<         /* covnert t ha-1 to kg DM m-2 */
<         rtot = s->root * TONNES_HA_2_KG_M2 / p->cfracts;
<         /*f->nuptake_old = f->nuptake; */
< 
<         calc_opt_root_depth(p->d0x, p->r0, p->topsoil_depth * MM_TO_M,
<                             rtot, nsupply, depth_guess, &s->root_depth,
<                             &f->nuptake, &f->rabove);
< 
<         /*umax = self.rm.calc_umax(f->nuptake) */
< 
<         /* covert nuptake from gN m-2 year-1  to t ha-1 day-1 */
<         f->nuptake = f->nuptake * G_M2_2_TONNES_HA * YRS_IN_DAYS;
< 
<         /* covert from kg DM N m-2 to t ha-1 */
<         f->deadroots = p->rdecay * f->rabove * p->cfracts * KG_M2_2_TONNES_HA;
<         f->deadrootn = s->rootnc * (1.0 - p->rretrans) * f->deadroots;
---
> void run_sim(control *c, fluxes *f, met *m, params *p, state *s){
> 
>     int nyr, doy, window_size, i;
>     int project_day = 0;
> 
>     double fdecay, rdecay, current_limitation, nitfac, year;
> 
>     /* potentially allocating 1 extra spot, but will be fine as we always
>        index by num_days */
>     double *day_length = NULL;
>     if ((day_length = (double *)calloc(366, sizeof(double))) == NULL) {
>         fprintf(stderr,"Error allocating space for day_length\n");
> 		exit(EXIT_FAILURE);
366,371d159
<     /* Mineralised nitrogen lost from the system by volatilisation/leaching */
<     f->nloss = p->rateloss * s->inorgn;
< 
<     /* total nitrogen to allocate */
<     ntot = MAX(0.0, f->nuptake + f->retrans);
< 
373,480c161,183
<         /* allocate N to pools with fixed N:C ratios */
< 
<         /* N flux into new ring (immobile component -> structrual components) */
<         f->npstemimm = f->wnimrate * s->growing_days[doy];
< 
<         /* N flux into new ring (mobile component -> can be retrans for new
<            woody tissue) */
<         f->npstemmob = f->wnmobrate * s->growing_days[doy];
<         f->nproot = s->n_to_alloc_root / c->num_days;
<         f->npcroot = f->cnrate * s->growing_days[doy];
<         f->npleaf = f->lnrate * s->growing_days[doy];
<         f->npbranch = f->bnrate * s->growing_days[doy];
<     } else {
<         /* allocate N to pools with fixed N:C ratios */
< 
<         /* N flux into new ring (immobile component -> structural components) */
<         f->npstemimm = f->npp * f->alstem * ncwimm;
< 
<         /* N flux into new ring (mobile component -> can be retrans for new
<            woody tissue) */
<         f->npstemmob = f->npp * f->alstem * (ncwnew - ncwimm);
<         f->npbranch = f->npp * f->albranch * ncbnew;
<         f->npcroot = f->npp * f->alcroot * nccnew;
< 
<         /* If we have allocated more N than we have available
<             - cut back C prodn */
<         arg = f->npstemimm + f->npstemmob + f->npbranch + f->npcroot;
< 
<         if (arg > ntot && c->fixleafnc == FALSE && c->ncycle && OLD == FALSE) {
< 
<             /* arbitarily keep 10% for leaves/roots */
<             double leaf_root_N = 0.1 * ntot;
< 
<             /* Rescale allocated N to the amount we actually have available */
<             total_req = f->npstemimm + f->npstemmob + f->npbranch + f->npcroot;
< 
<             f->npstemimm = (f->npstemimm / total_req) * (ntot - leaf_root_N);
<             f->npstemmob = (f->npstemmob / total_req) * (ntot - leaf_root_N);
<             f->npbranch = (f->npbranch / total_req) * (ntot - leaf_root_N);
<             f->npcroot = (f->npcroot / total_req) * (ntot - leaf_root_N);
< 
<         } else if (arg > ntot && c->fixleafnc == FALSE && c->ncycle && OLD) {
< 
<             /* Need to readjust the LAI for the reduced growth as this will
<                have already been increased. First we need to figure out how
<                much we have increased LAI by, important it is done here
<                before cpleaf is reduced! */
<             if (float_eq(s->shoot, 0.0)) {
<                 lai_inc = 0.0;
<             } else {
<                 lai_inc = (f->cpleaf *
<                            (p->sla * M2_AS_HA / (KG_AS_TONNES * p->cfracts)) -
<                            (f->deadleaves + f->ceaten) * s->lai / s->shoot);
<             }
< 
<             f->npp *= ntot / (f->npstemimm + f->npstemmob + f->npbranch+ f->npcroot);
< 
< 
< 
< 
< 
<             /* need to adjust growth values accordingly as well */
<             f->cpleaf = f->npp * f->alleaf;
<             f->cproot = f->npp * f->alroot;
<             f->cpcroot = f->npp * f->alcroot;
<             f->cpbranch = f->npp * f->albranch;
<             f->cpstem = f->npp * f->alstem;
< 
<             f->npbranch = f->npp * f->albranch * ncbnew;
<             f->npstemimm = f->npp * f->alstem * ncwimm;
<             f->npstemmob = f->npp * f->alstem * (ncwnew - ncwimm);
<             f->npcroot = f->npp * f->alcroot * nccnew;
< 
<             /* Also need to recalculate GPP and thus Ra and return a flag
<                so that we know to recalculate the water balance. */
<             f->gpp = f->npp / p->cue;
<             conv = G_AS_TONNES / M2_AS_HA;
<             f->gpp_gCm2 = f->gpp / conv;
<             f->gpp_am = f->gpp_gCm2 / 2.0;
<             f->gpp_pm = f->gpp_gCm2 / 2.0;
< 
<             /* New respiration flux */
<             f->auto_resp =  f->gpp - f->npp;
<             recalc_wb = TRUE;
< 
<             /* Now reduce LAI for down-regulated growth. */
<             if (c->deciduous_model) {
<                 if (float_eq(s->shoot, 0.0)) {
<                     s->lai = 0.0;
<                 } else if (s->leaf_out_days[doy] > 0.0) {
<                     s->lai -= lai_inc;
<                     s->lai += (f->cpleaf *
<                                (p->sla * M2_AS_HA / (KG_AS_TONNES * p->cfracts)) -
<                                (f->deadleaves + f->ceaten) * s->lai / s->shoot);
<                 } else {
<                     s->lai = 0.0;
<                 }
<             } else {
<                 /* update leaf area [m2 m-2] */
<                 if (float_eq(s->shoot, 0.0)) {
<                     s->lai = 0.0;
<                 } else {
<                     s->lai -= lai_inc;
<                     s->lai += (f->cpleaf *
<                                (p->sla * M2_AS_HA / (KG_AS_TONNES * p->cfracts)) -
<                                (f->deadleaves + f->ceaten) * s->lai / s->shoot);
<                 }
<             }
---
>         /* Are we reading in last years average growing season? */
>         if (float_eq(s->avg_alleaf, 0.0) &&
>             float_eq(s->avg_alstem, 0.0) &&
>             float_eq(s->avg_albranch, 0.0) &&
>             float_eq(s->avg_alleaf, 0.0) &&
>             float_eq(s->avg_alroot, 0.0) &&
>             float_eq(s->avg_alcroot, 0.0)) {
>             nitfac = 0.0;
>             calc_carbon_allocation_fracs(c, f, p, s, nitfac);
>         } else {
>             f->alleaf = s->avg_alleaf;
>             f->alstem = s->avg_alstem;
>             f->albranch = s->avg_albranch;
>             f->alroot = s->avg_alroot;
>             f->alcroot = s->avg_alcroot;
>         }
>         allocate_stored_c_and_n(f, p, s);
>     }
> 
>     /* Setup output file */
>     if (c->print_options == DAILY && c->spin_up == FALSE) {
>         /* Daily outputs */
>         open_output_file(c, c->out_fname, &(c->ofp));
481a185,189
>         if (c->output_ascii) {
>             write_output_header(c, &(c->ofp));
>         } else {
>             open_output_file(c, c->out_fname_hdr, &(c->ofp_hdr));
>             write_output_header(c, &(c->ofp_hdr));
483,490c191,193
< 
<         ntot -= f->npbranch + f->npstemimm + f->npstemmob + f->npcroot;
<         ntot = MAX(0.0, ntot);
< 
<         /* allocate remaining N to flexible-ratio pools */
<         f->npleaf = ntot * f->alleaf / (f->alleaf + f->alroot * p->ncrfac);
<         f->nproot = ntot - f->npleaf;
< 
---
>     } else if (c->print_options == END && c->spin_up == FALSE) {
>         /* Final state + param file */
>         open_output_file(c, c->out_param_fname, &(c->ofp));
492,526d194
<     return (recalc_wb);
< }
< 
< 
< double calculate_growth_stress_limitation(params *p, state *s) {
<     /* Calculate level of stress due to nitrogen or water availability """
<        calculate the N limitation based on available canopy N
<        this logic appears counter intuitive, but it works out when
<        applied with the perhaps backwards logic below */
<     double nlim, current_limitation;
< 
<     /* case - completely limited by N availability */
<     if (s->shootnc < p->nf_min) {
<         nlim = 0.0;
<     } else if (s->shootnc < p->nf_crit) {
<         nlim = (s->shootnc - p->nf_min) / (p->nf_crit - p->nf_min);
<     /* case - no N limitation */
<     } else {
<         nlim = 1.0;
<     }
< 
<     /* Limitation by nitrogen and water. Water constraint is implicit,
<        in that, water stress results in an increase of root mass,
<        which are assumed to spread horizontally within the rooting zone.
<        So in effect, building additional root mass doesnt alleviate the
<        water limitation within the model. However, it does more
<        accurately reflect an increase in root C production at a water
<        limited site. This implementation is also consistent with other
<        approaches, e.g. LPJ. In fact I dont see much evidence for models
<        that have a flexible bucket depth. Minimum constraint is limited to
<        0.1, following Zaehle et al. 2010 (supp), eqn 18. */
<     current_limitation = MAX(0.1, MIN(nlim, s->wtfac_root));
<     return (current_limitation);
< }
< 
528,551c196,211
< void calc_carbon_allocation_fracs(control *c, fluxes *f, params *p, state *s,
<                                   double nitfac) {
<     /* Carbon allocation fractions to move photosynthate through the plant.
< 
<     Parameters:
<     -----------
<     nitfac : float
<         leaf N:C as a fraction of 'Ncmaxfyoung' (max 1.0)
< 
<     Returns:
<     --------
<     alleaf : float
<         allocation fraction for shoot
<     alroot : float
<         allocation fraction for fine roots
<     albranch : float
<         allocation fraction for branches
<     alstem : float
<         allocation fraction for stem
< 
<     References:
<     -----------
<     Corbeels, M. et al (2005) Ecological Modelling, 187, 449-474.
<     McMurtrie, R. E. et al (2000) Plant and Soil, 224, 135-152.
---
>     /*
>         Window size = root lifespan in days...
>         For deciduous species window size is set as the length of the
>         growing season in the main part of the code
>     */
>     window_size = (int)(1.0 / p->rdecay * NDAYS_IN_YR);
>     sma_obj *hw = sma(SMA_NEW, window_size).handle;
>     if (s->prev_sma > -900) {
>         for (i = 0; i < window_size; i++) {
>             sma(SMA_ADD, hw, s->prev_sma);
>         }
>     }
>     /* Set up SMA
>     **  - If we don't have any information about the N & water limitation, i.e.
>     **    as would be the case with spin-up, assume that there is no limitation
>     **    to begin with.
553,556c213,214
<     double min_leaf_alloc, adj, arg1, arg2, arg3, arg4, leaf2sa_target,
<            sap_cross_sec_area, lr_max, stress, mis_match, orig_af, orig_ar,
<            reduction, target_branch, coarse_root_target, left_over,
<            total_alloc, leaf2sap, spare;
---
>     if (s->prev_sma < -900)
>         s->prev_sma = 1.0;
558,590c216,240
<     /* this is obviously arbitary */
<     double min_stem_alloc = 0.01;
< 
<     if (c->alloc_model == FIXED){
<         f->alleaf = (p->c_alloc_fmax + nitfac *
<                      (p->c_alloc_fmax - p->c_alloc_fmin));
< 
<         f->alroot = (p->c_alloc_rmax + nitfac *
<                      (p->c_alloc_rmax - p->c_alloc_rmin));
< 
<         f->albranch = (p->c_alloc_bmax + nitfac *
<                        (p->c_alloc_bmax - p->c_alloc_bmin));
< 
<         /* allocate remainder to stem */
<         f->alstem = 1.0 - f->alleaf - f->alroot - f->albranch;
< 
<         f->alcroot = p->c_alloc_cmax * f->alstem;
<         f->alstem -= f->alcroot;
< 
<     } else if (c->alloc_model == GRASSES) {
< 
<         /* First figure out root allocation given available water & nutrients
<            hyperbola shape to allocation */
<         f->alroot = (p->c_alloc_rmax * p->c_alloc_rmin /
<                      (p->c_alloc_rmin + (p->c_alloc_rmax - p->c_alloc_rmin) *
<                       s->prev_sma));
<         f->alleaf = 1.0 - f->alroot;
< 
<         /* Now adjust root & leaf allocation to maintain balance, accounting
<            for stress e.g. -> Sitch et al. 2003, GCB. */
< 
<         /* leaf-to-root ratio under non-stressed conditons */
<         lr_max = 0.8,
---
>     /*
>         params are defined in per year, needs to be per day. Important this is
>         done here as rate constants elsewhere in the code are assumed to be in
>         units of days not years
>     */
>     correct_rate_constants(p, FALSE);
>     day_end_calculations(c, p, s, -99, TRUE);
> 
>     initialise_soil_moisture_parameters(c, p);
>     s->pawater_root = p->wcapac_root;
>     s->pawater_topsoil = p->wcapac_topsoil;
> 
>     s->lai = MAX(0.01, (p->sla * M2_AS_HA / KG_AS_TONNES /
>                         p->cfracts * s->shoot));
> 
>     /* ====================== **
>     **   Y E A R    L O O P   **
>     ** ====================== */
>     project_day = 0;
>     for (nyr = 0; nyr < c->num_years; nyr++) {
>         year = m->year[project_day];
>         if (is_leap_year(year))
>             c->num_days = 366;
>         else
>             c->num_days = 365;
592,594c242
<         /* Calculate adjustment on lr_max, based on current "stress"
<            calculated from running mean of N and water stress */
<         stress = lr_max * s->prev_sma;
---
>         calculate_daylength(c->num_days, p->latitude, *(&day_length));
596,597c244,245
<         /* calculate new allocation fractions based on imbalance in *biomass* */
<         mis_match = s->shoot / (s->root * stress);
---
>         if (c->deciduous_model) {
>             phenology(c, f, m, p, s, day_length, project_day);
598a247,254
>             /* Change window size to length of growing season */
>             sma(SMA_FREE, hw);
>             hw = sma(SMA_NEW, p->growing_seas_len).handle;
>             if (s->prev_sma > -900) {
>                 for (i = 0; i < p->growing_seas_len; i++) {
>                     sma(SMA_ADD, hw, s->prev_sma);
>                 }
>             }
600,646c256
<         if (mis_match > 1.0) {
<             /* reduce leaf allocation fraction */
<             adj = f->alleaf / mis_match;
<             f->alleaf = MAX(p->c_alloc_fmin, MIN(p->c_alloc_fmax, adj));
<             f->alroot = 1.0 - f->alleaf;
<         } else {
<             /* reduce root allocation */
<             adj = f->alroot * mis_match;
<             f->alroot = MAX(p->c_alloc_rmin, MIN(p->c_alloc_rmax, adj));
<             f->alleaf = 1.0 - f->alroot;
<         }
<         f->alstem = 0.0;
<         f->albranch = 0.0;
<         f->alcroot = 0.0;
< 
<     } else if (c->alloc_model == ALLOMETRIC) {
< 
<         /* Calculate tree height: allometric reln using the power function
<            (Causton, 1985) */
<         s->canht = p->heighto * pow(s->stem, p->htpower);
< 
<         /* LAI to stem sapwood cross-sectional area (As m-2 m-2)
<            (dimensionless)
<            Assume it varies between LS0 and LS1 as a linear function of tree
<            height (m) */
<         arg1 = s->sapwood * TONNES_AS_KG * M2_AS_HA;
<         arg2 = s->canht * p->density * p->cfracts;
<         sap_cross_sec_area = arg1 / arg2;
<         leaf2sap = s->lai / sap_cross_sec_area;
< 
<         /* Allocation to leaves dependant on height. Modification of pipe
<            theory, leaf-to-sapwood ratio is not constant above a certain
<            height, due to hydraulic constraints (Magnani et al 2000; Deckmyn
<            et al. 2006). */
< 
<         if (s->canht < p->height0) {
<             leaf2sa_target = p->leafsap0;
<         } else if (float_eq(s->canht, p->height1)) {
<             leaf2sa_target = p->leafsap1;
<         } else if (s->canht > p->height1) {
<             leaf2sa_target = p->leafsap1;
<         } else {
<             arg1 = p->leafsap0;
<             arg2 = p->leafsap1 - p->leafsap0;
<             arg3 = s->canht - p->height0;
<             arg4 = p->height1 - p->height0;
<             leaf2sa_target = arg1 + (arg2 * arg3 / arg4);
---
>             zero_stuff(c, s);
648,672c258,288
<         f->alleaf = alloc_goal_seek(leaf2sap, leaf2sa_target, p->c_alloc_fmax,
<                                     p->targ_sens);
< 
<         /* Allocation to branch dependent on relationship between the stem
<            and branch */
<         target_branch = p->branch0 * pow(s->stem, p->branch1);
<         f->albranch = alloc_goal_seek(s->branch, target_branch, p->c_alloc_bmax,
<                                       p->targ_sens);
< 
<         coarse_root_target = p->croot0 * pow(s->stem, p->croot1);
<         f->alcroot = alloc_goal_seek(s->croot, coarse_root_target,
<                                       p->c_alloc_cmax, p->targ_sens);
< 
< 
< 
<         /* figure out root allocation given available water & nutrients
<            hyperbola shape to allocation, this is adjusted below as we aim
<            to maintain a functional balance */
< 
<         f->alroot = (p->c_alloc_rmax * p->c_alloc_rmin /
<                      (p->c_alloc_rmin + (p->c_alloc_rmax - p->c_alloc_rmin) *
<                       s->prev_sma));
< 
<         /* Now adjust root & leaf allocation to maintain balance, accounting
<            for stress e.g. -> Sitch et al. 2003, GCB. */
---
>         /* =================== **
>         **   D A Y   L O O P   **
>         ** =================== */
> 
>         for (doy = 0; doy < c->num_days; doy++) {
> 
>             calculate_litterfall(c, f, p, s, doy, &fdecay, &rdecay);
> 
>             calc_day_growth(c, f, m, p, s, project_day, day_length[doy],
>                             doy, fdecay, rdecay);
> 
>             calculate_csoil_flows(c, f, p, s, m->tsoil[project_day], doy);
>             calculate_nsoil_flows(c, f, p, s, m->ndep[project_day], doy);
> 
>             /*printf("%f\n", f->gpp*100.);*/
> 
>             /* update stress SMA */
>             if (c->deciduous_model && s->leaf_out_days[doy] > 0.0) {
>                  /*Allocation is annually for deciduous "tree" model, but we
>                    need to keep a check on stresses during the growing season
>                    and the LAI figure out limitations during leaf growth period.
>                    This also applies for deciduous grasses, need to do the
>                    growth stress calc for grasses here too. */
>                 current_limitation = calculate_growth_stress_limitation(p, s);
>                 sma(SMA_ADD, hw, current_limitation);
>                 s->prev_sma = sma(SMA_MEAN, hw).sma;
>             } else if (c->deciduous_model == FALSE) {
>                 current_limitation = calculate_growth_stress_limitation(p, s);
>                 sma(SMA_ADD, hw, current_limitation);
>                 s->prev_sma = sma(SMA_MEAN, hw).sma;
>             }
674,675c290,297
<         /* leaf-to-root ratio under non-stressed conditons */
<         lr_max = 1.0;
---
>             /*
>                 if grazing took place need to reset "stress" running mean
>                 calculation for grasses
>             */
>             if (c->grazing == 2 && p->disturbance_doy == doy) {
>                 sma(SMA_FREE, hw);
>                 hw = sma(SMA_NEW, p->growing_seas_len).handle;
>             }
677,679c299,311
<         /* Calculate adjustment on lr_max, based on current "stress"
<            calculated from running mean of N and water stress */
<         stress = lr_max * s->prev_sma;
---
>             /* Turn off all N calculations */
>             if (c->ncycle == FALSE)
>                 reset_all_n_pools_and_fluxes(f, s);
> 
>             /* calculate C:N ratios and increment annual flux sum */
>             day_end_calculations(c, p, s, c->num_days, FALSE);
> 
>             if (c->print_options == DAILY && c->spin_up == FALSE) {
>                 if(c->output_ascii)
>                     write_daily_outputs_ascii(c, f, s, year, doy+1);
>                 else
>                     write_daily_outputs_binary(c, f, s, year, doy+1);
>             }
681,690d312
<         /* calculate imbalance, based on *biomass* */
<         if (c->deciduous_model) {
<             mis_match = s->shoot / (s->root * stress);
<         } else {
<             /* Catch for floating point reset of root C mass */
<             if (float_eq(s->root, 0.0))
<                 mis_match = 1.9;
<             else
<                 mis_match = s->shoot / (s->root * stress);
<         }
691a314,315
>             /* check the daily water balance */
>             /*check_water_balance(project_day); */
693,711c317,320
<         if (mis_match > 1.0) {
<             /* Root=Leaf biomass in out of balance, borrow from the stem to try
<                and alleviate this difference and move towards a functional
<                balance. I've set an aribitary max borrowing fraction of 0.5*/
<             spare = 1.0 - f->alleaf - f->albranch - f->alcroot - min_stem_alloc;
<             adj = f->alroot * mis_match;
<             f->alroot += MAX(p->c_alloc_rmin, MIN(spare, adj));
<             f->alroot = MIN(0.5, f->alroot);
< 
<         } else if (mis_match < 1.0) {
<             /* Root=Leaf biomass in out of balance, borrow from the root to try
<                and alleviate this difference and move towards a functional
<                balance */
<             /* reduce root allocation */
<             orig_ar = f->alroot;
<             adj = f->alroot * mis_match;
<             f->alroot = MAX(p->c_alloc_rmin, MIN(p->c_alloc_rmax, adj));
<             reduction = MAX(0.0, orig_ar - f->alroot);
<             f->alleaf += MAX(p->c_alloc_fmax, reduction);
---
>             project_day++;
>             /* ======================= **
>             **   E N D   O F   D A Y   **
>             ** ======================= */
714,732c323
< 
<         /* Ensure we don't end up with alloc fractions that make no
<            physical sense. */
<         left_over = 1.0 - f->alroot - f->alleaf;
<         if (f->albranch + f->alcroot > left_over) {
<             if (float_eq(s->croot, 0.0)) {
<                 f->alcroot = 0.0;
<                 f->alstem = 0.5 * left_over;
<                 f->albranch = 0.5 * left_over;
<             } else {
<                 f->alcroot = 0.3 * left_over;
<                 f->alstem = 0.4 * left_over;
<                 f->albranch = 0.3 * left_over;
<             }
<         }
<         f->alstem = 1.0 - f->alroot - f->albranch - f->alleaf - f->alcroot;
< 
<         /* minimum allocation to leaves - without it tree would die, as this
<            is done annually. */
---
>         /* Allocate stored C&N for the following year */
734,741c325,326
<             if (f->alleaf < 0.05) {
<                 min_leaf_alloc = 0.05;
<                 if (f->alstem > min_leaf_alloc)
<                     f->alstem -= min_leaf_alloc;
<                 else
<                     f->alroot -= min_leaf_alloc;
<                 f->alleaf = min_leaf_alloc;
<             }
---
>             calculate_average_alloc_fractions(f, s, p->growing_seas_len);
>             allocate_stored_c_and_n(f, p, s);
743,745d327
<     } else {
<         fprintf(stderr, "Unknown C allocation model: %d\n", c->alloc_model);
<         exit(EXIT_FAILURE);
746a329,331
>     /* ========================= **
>     **   E N D   O F   Y E A R   **
>     ** ========================= */
748c333
<     /*printf("%f %f %f %f %f\n", f->alleaf, f->albranch + f->alstem, f->alroot,  f->alcroot, s->canht);*/
---
>     correct_rate_constants(p, TRUE);
750,754c335,336
<     /* Total allocation should be one, if not print warning */
<     total_alloc = f->alroot + f->alleaf + f->albranch + f->alstem + f->alcroot;
<     if (total_alloc > 1.0+EPSILON) {
<         fprintf(stderr, "Allocation fracs > 1: %.13f\n", total_alloc);
<         exit(EXIT_FAILURE);
---
>     if (c->print_options == END && c->spin_up == FALSE) {
>         write_final_state(c, p, s);
757,759c339,340
<     return;
< }
< 
---
>     sma(SMA_FREE, hw);
>     free(day_length);
761,762c342
< double alloc_goal_seek(double simulated, double target, double alloc_max,
<                        double sensitivity) {
---
>     return;
764,768d343
<     /* Sensitivity parameter characterises how allocation fraction respond
<        when the leaf:sapwood area ratio departs from the target value
<        If sensitivity close to 0 then the simulated leaf:sapwood area ratio
<        will closely track the target value */
<     double frac = 0.5 + 0.5 * (1.0 - simulated / target) / sensitivity;
770d344
<     return MAX(0.0, alloc_max * MIN(1.0, frac));
773,796c347,348
< void carbon_allocation(control *c, fluxes *f, params *p, state *s,
<                        double nitfac, int doy) {
<     /* C distribution - allocate available C through system
< 
<     Parameters:
<     -----------
<     nitfac : float
<         leaf N:C as a fraction of 'Ncmaxfyoung' (max 1.0)
<     */
<     double days_left;
<     if (c->deciduous_model) {
<         days_left = s->growing_days[doy];
<         f->cpleaf = f->lrate * days_left;
<         f->cpbranch = f->brate * days_left;
<         f->cpstem = f->wrate * days_left;
<         f->cproot = s->c_to_alloc_root * 1.0 / c->num_days;
<         f->cpcroot = f->crate * days_left;
<     } else {
<         f->cpleaf = f->npp * f->alleaf;
<         f->cproot = f->npp * f->alroot;
<         f->cpcroot = f->npp * f->alcroot;
<         f->cpbranch = f->npp * f->albranch;
<         f->cpstem = f->npp * f->alstem;
<     }
---
> void spin_up_pools(control *c, fluxes *f, met *m, params *p, state *s){
>     /* Spin up model plant & soil pools to equilibrium.
798,804c350,352
<     /* evaluate SLA of new foliage accounting for variation in SLA
<        with tree and leaf age (Sands and Landsberg, 2002). Assume
<        SLA of new foliage is linearly related to leaf N:C ratio
<        via nitfac. Based on date from two E.globulus stands in SW Aus, see
<        Corbeels et al (2005) Ecological Modelling, 187, 449-474.
<        (m2 onesided/kg DW) */
<     p->sla = p->slazero + nitfac * (p->slamax - p->slazero);
---
>     - Examine sequences of 50 years and check if C pools are changing
>       by more than 0.005 units per 1000 yrs. Note this check is done in
>       units of: kg m-2.
806,819c354,375
<     if (c->deciduous_model) {
<         if (float_eq(s->shoot, 0.0)) {
<             s->lai = 0.0;
<         } else if (s->leaf_out_days[doy] > 0.0) {
<             s->lai += (f->cpleaf *
<                       (p->sla * M2_AS_HA / (KG_AS_TONNES * p->cfracts)) -
<                       (f->deadleaves + f->ceaten) * s->lai / s->shoot);
<         } else {
<             s->lai = 0.0;
<         }
<     } else {
<         /* update leaf area [m2 m-2] */
<         if (float_eq(s->shoot, 0.0)) {
<             s->lai = 0.0;
---
>     References:
>     ----------
>     Adapted from...
>     * Murty, D and McMurtrie, R. E. (2000) Ecological Modelling, 134,
>       185-205, specifically page 196.
>     */
>     double tol = 5E-03;
>     double prev_plantc = 99999.9;
>     double prev_soilc = 99999.9;
>     int i;
>     /* check for convergences in units of kg/m2 */
>     double conv = TONNES_HA_2_KG_M2;
> 
> 
>     /* Final state + param file */
>     open_output_file(c, c->out_param_fname, &(c->ofp));
> 
>     fprintf(stderr, "Spinning up the model...\n");
>     while (TRUE) {
>         if (fabs((prev_plantc*conv) - (s->plantc*conv)) < tol &&
>             fabs((prev_soilc*conv) - (s->soilc*conv)) < tol) {
>             break;
821,823c377,386
<             s->lai += (f->cpleaf *
<                       (p->sla * M2_AS_HA / (KG_AS_TONNES * p->cfracts)) -
<                       (f->deadleaves + f->ceaten) * s->lai / s->shoot);
---
>             prev_plantc = s->plantc;
>             prev_soilc = s->soilc;
> 
>             /* 1000 years (50 yrs x 20 cycles) */
>             for (i = 0; i < 20; i++)
>                 run_sim(c, f, m, p, s); /* run GDAY */
> 
>             /* Have we reached a steady state? */
>             fprintf(stderr, "Spinup: Plant C - %f, Soil C - %f\n",
>                     s->plantc, s->soilc);
825a389
>     write_final_state(c, p, s);
830,844c394,395
< void update_plant_state(control *c, fluxes *f, params *p, state *s,
<                         double fdecay, double rdecay, int doy) {
<     /*
<     Daily change in C content
< 
<     Parameters:
<     -----------
<     fdecay : float
<         foliage decay rate
<     rdecay : float
<         fine root decay rate
< 
<     */
< 
<     double age_effect, ncmaxf, ncmaxr, extras, extrar;
---
> void clparser(int argc, char **argv, control *c) {
>     int i;
846,918c397,413
<     /*
<     ** Carbon pools
<     */
<     s->shoot += f->cpleaf - f->deadleaves - f->ceaten;
<     s->root += f->cproot - f->deadroots;
<     s->croot += f->cpcroot - f->deadcroots;
<     s->branch += f->cpbranch - f->deadbranch;
<     s->stem += f->cpstem - f->deadstems;
< 
<     /* annoying but can't see an easier way with the code as it is.
<        If we are modelling grases, i.e. no stem them without this
<        the sapwood will end up being reduced to a silly number as
<        deadsapwood will keep being removed from the pool, even though there
<        is no wood. */
<     if (float_eq(s->stem, 0.01)) {
<         s->sapwood = 0.01;
<     } else if (s->stem < 0.01) {
<         s->sapwood = 0.01;
<     } else {
<         s->sapwood += f->cpstem - f->deadsapwood;
<     }
< 
< 
<     /*
<     ** Nitrogen pools
<     */
<     if (c->deciduous_model) {
<         s->shootn += (f->npleaf - (f->lnrate * s->remaining_days[doy]) -
<                       f->neaten);
<     } else {
<         s->shootn += f->npleaf - fdecay * s->shootn - f->neaten;
<     }
<     s->branchn += f->npbranch - p->bdecay * s->branchn;
<     s->rootn += f->nproot - rdecay * s->rootn;
<     s->crootn += f->npcroot - p->crdecay * s->crootn;
<     s->stemnimm += f->npstemimm - p->wdecay * s->stemnimm;
<     s->stemnmob += (f->npstemmob - p->wdecay * s->stemnmob - p->retransmob *
<                     s->stemnmob);
<     s->stemn = s->stemnimm + s->stemnmob;
< 
< 
<     if (c->deciduous_model == FALSE) {
<         /*
<            =============================
<             Enforce maximum N:C ratios.
<            =============================
<         */
< 
<         /* If foliage or root N/C exceeds its max, then N uptake is cut back*/
< 
<         /* maximum leaf n:c ratio is function of stand age
<             - switch off age effect by setting ncmaxfyoung = ncmaxfold */
<         age_effect = (s->age - p->ageyoung) / (p->ageold - p->ageyoung);
<         ncmaxf = p->ncmaxfyoung - (p->ncmaxfyoung - p->ncmaxfold) * age_effect;
< 
<         if (ncmaxf < p->ncmaxfold)
<             ncmaxf = p->ncmaxfold;
< 
<         if (ncmaxf > p->ncmaxfyoung)
<             ncmaxf = p->ncmaxfyoung;
< 
<         extras = 0.0;
<         if (s->lai > 0.0) {
< 
<             if (s->shootn > (s->shoot * ncmaxf)) {
<                 extras = s->shootn - s->shoot * ncmaxf;
< 
<                 /* Ensure N uptake cannot be reduced below zero. */
<                 if (extras >  f->nuptake)
<                     extras = f->nuptake;
< 
<                 s->shootn -= extras;
<                 f->nuptake -= extras;
---
>     for (i = 1; i < argc; i++) {
>         if (*argv[i] == '-') {
>             if (!strncasecmp(argv[i], "-p", 2)) {
> 			    strcpy(c->cfg_fname, argv[++i]);
>             } else if (!strncasecmp(argv[i], "-s", 2)) {
>                 c->spin_up = TRUE;
>             } else if (!strncasecmp(argv[i], "-ver", 4)) {
>                 c->PRINT_GIT = TRUE;
>             } else if (!strncasecmp(argv[i], "-u", 2) ||
>                        !strncasecmp(argv[i], "-h", 2)) {
>                 usage(argv);
>                 exit(EXIT_FAILURE);
>             } else {
>                 fprintf(stderr, "%s: unknown argument on command line: %s\n",
>                                argv[0], argv[i]);
>                 usage(argv);
>                 exit(EXIT_FAILURE);
921,938d415
< 
<         /* if root N:C ratio exceeds its max, then nitrogen uptake is cut
<            back. n.b. new ring n/c max is already set because it is related
<            to leaf n:c */
< 
<         /* max root n:c */
<         ncmaxr = ncmaxf * p->ncrfac;
<         extrar = 0.0;
<         if (s->rootn > (s->root * ncmaxr)) {
<             extrar = s->rootn - s->root * ncmaxr;
< 
<             /* Ensure N uptake cannot be reduced below zero. */
<             if ((extras + extrar) > f->nuptake)
<                 extrar = f->nuptake - extras;
< 
<             s->rootn -= extrar;
<             f->nuptake -= extrar;
<         }
940,943d416
<     /* Update deciduous storage pools */
<     if (c->deciduous_model)
<         calculate_cn_store(f, s);
< 
947,959d419
< void precision_control(fluxes *f, state *s) {
<     /* Detect very low values in state variables and force to zero to
<     avoid rounding and overflow errors */
< 
<     double tolerance = 1E-10;
< 
<     /* C & N state variables */
<     if (s->shoot < tolerance) {
<         f->deadleaves += s->shoot;
<         f->deadleafn += s->shootn;
<         s->shoot = 0.0;
<         s->shootn = 0.0;
<     }
961,966c421,433
<     if (s->branch < tolerance) {
<         f->deadbranch += s->branch;
<         f->deadbranchn += s->branchn;
<         s->branch = 0.0;
<         s->branchn = 0.0;
<     }
---
> void usage(char **argv) {
>     fprintf(stderr, "\n========\n");
>     fprintf(stderr, " USAGE:\n");
>     fprintf(stderr, "========\n");
>     fprintf(stderr, "\t%s [options]\n", argv[0]);
>     fprintf(stderr, "\n\nExpected input file is a .ini/.cfg style param file, passed with the -p flag .\n");
>     fprintf(stderr, "\nThe options are:\n");
>     fprintf(stderr, "\n++General options:\n" );
>     fprintf(stderr, "[-ver          \t] Print the git hash tag.]\n");
>     fprintf(stderr, "[-p       fname\t] Location of parameter file (.ini/.cfg).]\n");
>     fprintf(stderr, "[-s            \t] Spin-up GDAY, when it the model is finished it will print the final state to the param file.]\n");
>     fprintf(stderr, "\n++Print this message:\n" );
>     fprintf(stderr, "[-u/-h         \t] usage/help]\n");
968,973c435,436
<     if (s->root < tolerance) {
<         f->deadrootn += s->rootn;
<         f->deadroots += s->root;
<         s->root = 0.0;
<         s->rootn = 0.0;
<     }
---
>     return;
> }
975,980d437
<     if (s->croot < tolerance) {
<         f->deadcrootn += s->crootn;
<         f->deadcroots += s->croot;
<         s->croot = 0.0;
<         s->crootn = 0.0;
<     }
982,983d438
<     /* Not setting these to zero as this just leads to errors with desert
<        regrowth...instead seeding them to a small value with a CN~25. */
985,992d439
<     if (s->stem < tolerance) {
<         f->deadstems += s->stem;
<         f->deadstemn += s->stemn;
<         s->stem = 0.001;
<         s->stemn = 0.00004;
<         s->stemnimm = 0.00004;
<         s->stemnmob = 0.0;
<     }
994,999d440
<     /* need separate one as this will become very small if there is no
<        mobile stem N */
<     if (s->stemnmob < tolerance) {
<         f->deadstemn += s->stemnmob;
<         s->stemnmob = 0.0;
<     }
1001,1003c442,486
<     if (s->stemnimm < tolerance) {
<         f->deadstemn += s->stemnimm;
<         s->stemnimm = 0.00004;
---
> void correct_rate_constants(params *p, int output) {
>     /* adjust rate constants for the number of days in years */
> 
>     if (output) {
>         p->rateuptake *= NDAYS_IN_YR;
>         p->rateloss *= NDAYS_IN_YR;
>         p->retransmob *= NDAYS_IN_YR;
>         p->fdecay *= NDAYS_IN_YR;
>         p->fdecaydry *= NDAYS_IN_YR;
>         p->crdecay *= NDAYS_IN_YR;
>         p->rdecay *= NDAYS_IN_YR;
>         p->rdecaydry *= NDAYS_IN_YR;
>         p->bdecay *= NDAYS_IN_YR;
>         p->wdecay *= NDAYS_IN_YR;
>         p->sapturnover *= NDAYS_IN_YR;
>         p->kdec1 *= NDAYS_IN_YR;
>         p->kdec2 *= NDAYS_IN_YR;
>         p->kdec3 *= NDAYS_IN_YR;
>         p->kdec4 *= NDAYS_IN_YR;
>         p->kdec5 *= NDAYS_IN_YR;
>         p->kdec6 *= NDAYS_IN_YR;
>         p->kdec7 *= NDAYS_IN_YR;
>         p->nuptakez *= NDAYS_IN_YR;
>         p->nmax *= NDAYS_IN_YR;
>     } else {
>         p->rateuptake /= NDAYS_IN_YR;
>         p->rateloss /= NDAYS_IN_YR;
>         p->retransmob /= NDAYS_IN_YR;
>         p->fdecay /= NDAYS_IN_YR;
>         p->fdecaydry /= NDAYS_IN_YR;
>         p->crdecay /= NDAYS_IN_YR;
>         p->rdecay /= NDAYS_IN_YR;
>         p->rdecaydry /= NDAYS_IN_YR;
>         p->bdecay /= NDAYS_IN_YR;
>         p->wdecay /= NDAYS_IN_YR;
>         p->sapturnover /= NDAYS_IN_YR;
>         p->kdec1 /= NDAYS_IN_YR;
>         p->kdec2 /= NDAYS_IN_YR;
>         p->kdec3 /= NDAYS_IN_YR;
>         p->kdec4 /= NDAYS_IN_YR;
>         p->kdec5 /= NDAYS_IN_YR;
>         p->kdec6 /= NDAYS_IN_YR;
>         p->kdec7 /= NDAYS_IN_YR;
>         p->nuptakez /= NDAYS_IN_YR;
>         p->nmax /= NDAYS_IN_YR;
1010,1014c493,496
< void calculate_cn_store(fluxes *f, state *s) {
<     /*
<     Deciduous trees store carbohydrate during the winter which they then
<     use in the following year to build new leaves (buds & budburst are
<     implied)
---
> void reset_all_n_pools_and_fluxes(fluxes *f, state *s) {
>     /* If the N-Cycle is turned off the way I am implementing this is to
>        do all the calculations and then reset everything at the end. This is
>        a waste of resources but saves on multiple IF statements.
1017,1040d498
<     /* Total C & N storage to allocate annually. */
<     s->cstore += f->npp;
<     s->nstore += f->nuptake + f->retrans;
<     s->anpp += f->npp;
< 
<     return;
< }
< 
< 
< void calculate_average_alloc_fractions(fluxes *f, state *s, int days) {
<     double excess;
< 
<     s->avg_alleaf /= (float) days;
<     s->avg_alroot /= (float) days;
<     s->avg_alcroot /= (float) days;
<     s->avg_albranch /= (float) days;
<     s->avg_alstem /= (float) days;
< 
<     f->alleaf = s->avg_alleaf;
<     f->alroot = s->avg_alroot;
<     f->alcroot = s->avg_alcroot;
<     f->albranch = s->avg_albranch;
<     f->alstem = s->avg_alstem;
< 
1042,1044c500
<         Because we are taking the average growing season fracs the total may
<         end up being just under 1, due to rounding. So put the missing
<         bit into the leaves - arbitary decision there
---
>     ** State
1046,1050c502,519
<     excess = 1.0 - f->alleaf - f->alroot - f->alcroot - f->albranch - f->alstem;
<     f->alleaf += excess;
< 
<     return;
< }
---
>     s->shootn = 0.0;
>     s->rootn = 0.0;
>     s->crootn = 0.0;
>     s->branchn = 0.0;
>     s->stemnimm = 0.0;
>     s->stemnmob = 0.0;
>     s->structsurfn = 0.0;
>     s->metabsurfn = 0.0;
>     s->structsoiln = 0.0;
>     s->metabsoiln = 0.0;
>     s->activesoiln = 0.0;
>     s->slowsoiln = 0.0;
>     s->passivesoiln = 0.0;
>     s->inorgn = 0.0;
>     s->stemn = 0.0;
>     s->stemnimm = 0.0;
>     s->stemnmob = 0.0;
>     s->nstore = 0.0;
1052d520
< void allocate_stored_c_and_n(fluxes *f, params *p, state *s) {
1054,1055c522
<     Allocate stored C&N. This is either down as the model is initialised
<     for the first time or at the end of each year.
---
>     ** Fluxes
1057,1095c524,559
<     double ntot;
< 
<     /* ========================
<        Carbon - fixed fractions
<        ======================== */
<     s->c_to_alloc_shoot = f->alleaf * s->cstore;
<     s->c_to_alloc_root = f->alroot * s->cstore;
<     s->c_to_alloc_croot = f->alcroot * s->cstore;
<     s->c_to_alloc_branch = f->albranch * s->cstore;
<     s->c_to_alloc_stem = f->alstem * s->cstore;
< 
<     /* =========================================================
<         Nitrogen - Fixed ratios N allocation to woody components.
<        ========================================================= */
< 
<     /* N flux into new ring (immobile component -> structrual components) */
<     s->n_to_alloc_stemimm = s->cstore * f->alstem * p->ncwimm;
< 
<     /* N flux into new ring (mobile component -> can be retrans for new
<        woody tissue) */
<     s->n_to_alloc_stemmob = s->cstore * f->alstem * (p->ncwnew - p->ncwimm);
<     s->n_to_alloc_branch = s->cstore * f->albranch * p->ncbnew;
<     s->n_to_alloc_croot = s->cstore * f->alcroot * p->nccnew;
< 
<     /* Calculate remaining N left to allocate to leaves and roots */
<     ntot = MAX(0.0, (s->nstore - s->n_to_alloc_stemimm - s->n_to_alloc_stemmob -
<                      s->n_to_alloc_branch));
< 
<     /* allocate remaining N to flexible-ratio pools */
<     s->n_to_alloc_shoot = (ntot * f->alleaf /
<                             (f->alleaf + f->alroot * p->ncrfac));
<     s->n_to_alloc_root = ntot - s->n_to_alloc_shoot;
< 
<     /*
<     leaf_NC = s->n_to_alloc_shoot / s->c_to_alloc_shoot
<     if leaf_NC > 0.04:
<         s->n_to_alloc_shoot = s->c_to_alloc_shoot * 0.14
< 
<     s->n_to_alloc_root = ntot - s->n_to_alloc_shoot
---
>     f->nuptake = 0.0;
>     f->nloss = 0.0;
>     f->npassive = 0.0;
>     f->ngross = 0.0;
>     f->nimmob = 0.0;
>     f->nlittrelease = 0.0;
>     f->nmineralisation = 0.0;
>     f->npleaf = 0.0;
>     f->nproot = 0.0;
>     f->npcroot = 0.0;
>     f->npbranch = 0.0;
>     f->npstemimm = 0.0;
>     f->npstemmob = 0.0;
>     f->deadleafn = 0.0;
>     f->deadrootn = 0.0;
>     f->deadcrootn = 0.0;
>     f->deadbranchn = 0.0;
>     f->deadstemn = 0.0;
>     f->neaten = 0.0;
>     f->nurine = 0.0;
>     f->leafretransn = 0.0;
>     f->n_surf_struct_litter = 0.0;
>     f->n_surf_metab_litter = 0.0;
>     f->n_soil_struct_litter = 0.0;
>     f->n_soil_metab_litter = 0.0;
>     f->n_surf_struct_to_slow = 0.0;
>     f->n_soil_struct_to_slow = 0.0;
>     f->n_surf_struct_to_active = 0.0;
>     f->n_soil_struct_to_active = 0.0;
>     f->n_surf_metab_to_active = 0.0;
>     f->n_surf_metab_to_active = 0.0;
>     f->n_active_to_slow = 0.0;
>     f->n_active_to_passive = 0.0;
>     f->n_slow_to_active = 0.0;
>     f->n_slow_to_passive = 0.0;
>     f->n_passive_to_active = 0.0;
1096a561,562
>     return;
> }
1098,1102c564,571
<     root_NC = s->n_to_alloc_root / s->c_to_alloc_root
<     ncmaxr = 0.04 * p->ncrfac
<     if root_NC > ncmaxr:
<         extrar = (s->n_to_alloc_root -
<                   (s->c_to_alloc_root * ncmaxr))
---
> void zero_stuff(control *c, state *s) {
>     s->shoot = 0.0;
>     s->shootn = 0.0;
>     s->shootnc = 0.0;
>     s->lai = 0.0;
>     s->cstore = 0.0;
>     s->nstore = 0.0;
>     s->anpp = 0.0;
1104,1106c573,579
<         s->inorgn += extrar
<         s->n_to_alloc_root -= extrar
<     */
---
>     if (c->deciduous_model) {
>         s->avg_alleaf = 0.0;
>         s->avg_alroot = 0.0;
>         s->avg_alcroot = 0.0;
>         s->avg_albranch  = 0.0;
>         s->avg_alstem = 0.0;
>     }
1110,1114c583,585
< 
< double nitrogen_retrans(control *c, fluxes *f, params *p, state *s,
<                         double fdecay, double rdecay, int doy) {
<     /* Nitrogen retranslocated from senesced plant matter.
<     Constant rate of n translocated from mobile pool
---
> void day_end_calculations(control *c, params *p, state *s, int days_in_year,
>                           int init) {
>     /* Calculate derived values from state variables.
1118,1126c589,590
<     fdecay : float
<         foliage decay rate
<     rdecay : float
<         fine root decay rate
< 
<     Returns:
<     --------
<     N retrans : float
<         N retranslocated plant matter
---
>     day : integer
>         day of simulation
1127a592,593
>     INIT : logical
>         logical defining whether it is the first day of the simulation
1129,1145d594
<     double leafretransn, rootretransn, crootretransn, branchretransn,
<            stemretransn;
< 
<     if (c->deciduous_model) {
<         leafretransn = p->fretrans * f->lnrate * s->remaining_days[doy];
<     } else {
<         leafretransn = p->fretrans * fdecay * s->shootn;
<     }
< 
<     rootretransn = p->rretrans * rdecay * s->rootn;
<     crootretransn = p->cretrans * p->crdecay * s->crootn;
<     branchretransn = p->bretrans * p->bdecay * s->branchn;
<     stemretransn = (p->wretrans * p->wdecay * s->stemnmob + p->retransmob *
<                     s->stemnmob);
< 
<     /* store for NCEAS output */
<     f->leafretransn = leafretransn;
1147,1159c596,600
<     return (leafretransn + rootretransn + crootretransn + branchretransn +
<             stemretransn);
< }
< 
< 
< double calculate_nuptake(control *c, params *p, state *s) {
<     /* N uptake depends on the rate at which soil mineral N is made
<     available to the plants.
< 
<     Returns:
<     --------
<     nuptake : float
<         N uptake
---
>     /* update N:C of plant pool */
>     if (float_eq(s->shoot, 0.0))
>         s->shootnc = 0.0;
>     else
>         s->shootnc = s->shootn / s->shoot;
1161,1164c602,604
<     References:
<     -----------
<     * Dewar and McMurtrie, 1996, Tree Physiology, 16, 161-171.
<     * Raich et al. 1991, Ecological Applications, 1, 399-429.
---
>     /* Explicitly set the shoot N:C */
>     if (c->ncycle == FALSE)
>         s->shootnc = p->prescribed_leaf_NC;
1166,1167c606,609
<     */
<     double nuptake, U0, Kr;
---
>     if (float_eq(s->root, 0.0))
>         s->rootnc = 0.0;
>     else
>         s->rootnc = MAX(0.0, s->rootn / s->root);
1169,1193c611,635
<     if (c->nuptake_model == 0) {
<         /* Constant N uptake */
<         nuptake = p->nuptakez;
<     } else if (c->nuptake_model == 1) {
<         /* evaluate nuptake : proportional to dynamic inorganic N pool */
<         nuptake = p->rateuptake * s->inorgn;
<     } else if (c->nuptake_model == 2) {
<         /* N uptake is a saturating function on root biomass following
<            Dewar and McMurtrie, 1996. */
< 
<         /* supply rate of available mineral N */
<         U0 = p->rateuptake * s->inorgn;
<         Kr = p->kr;
<         nuptake = MAX(U0 * s->root / (s->root + Kr), 0.0);
< 
<         /* Make minimum uptake rate supply rate for deciduous_model cases
<            otherwise it is possible when growing from scratch we don't have
<            enough root mass to obtain N at the annual time step
<            I don't see an obvious better solution?
<         if c->deciduous_model:
<             nuptake = max(U0 * s->root / (s->root + Kr), U0) */
<     } else {
<         fprintf(stderr, "Unknown N uptake option\n");
<         exit(EXIT_FAILURE);
<     }
---
>     /* total plant, soil & litter nitrogen */
>     s->soiln = s->inorgn + s->activesoiln + s->slowsoiln + s->passivesoiln;
>     s->litternag = s->structsurfn + s->metabsurfn;
>     s->litternbg = s->structsoiln + s->metabsoiln;
>     s->littern = s->litternag + s->litternbg;
>     s->plantn = s->shootn + s->rootn + s->crootn + s->branchn + s->stemn;
>     s->totaln = s->plantn + s->littern + s->soiln;
> 
>     /* total plant, soil, litter and system carbon */
>     s->soilc = s->activesoil + s->slowsoil + s->passivesoil;
>     s->littercag = s->structsurf + s->metabsurf;
>     s->littercbg = s->structsoil + s->metabsoil;
>     s->litterc = s->littercag + s->littercbg;
>     s->plantc = s->root + s->croot + s->shoot + s->stem + s->branch;
>     s->totalc = s->soilc + s->litterc + s->plantc;
> 
>     /* optional constant passive pool */
>     if (c->passiveconst) {
>         s->passivesoil = p->passivesoilz;
>         s->passivesoiln = p->passivesoilnz;
>     }
> 
>     if (init == FALSE)
>         /* Required so max leaf & root N:C can depend on Age */
>         s->age += 1.0 / days_in_year;
1195c637
<     return (nuptake);
---
>     return;
